diff --git a/node_modules/instantsearch.js/es/lib/InstantSearch.js b/node_modules/instantsearch.js/es/lib/InstantSearch.js
index 142f37c..b1bf4e7 100644
--- a/node_modules/instantsearch.js/es/lib/InstantSearch.js
+++ b/node_modules/instantsearch.js/es/lib/InstantSearch.js
@@ -90,7 +90,9 @@ function (_EventEmitter) {
     _defineProperty(_assertThisInitialized(_this), "middleware", []);
 
     _defineProperty(_assertThisInitialized(_this), "scheduleSearch", defer(function () {
-      _this.mainHelper.search();
+      if (_this.started) {
+        _this.mainHelper.search();
+      }
     }));
 
     _defineProperty(_assertThisInitialized(_this), "scheduleRender", defer(function () {
diff --git a/node_modules/instantsearch.js/es/lib/escape-highlight.js b/node_modules/instantsearch.js/es/lib/escape-highlight.js
index 62c38c3..548e1b5 100644
--- a/node_modules/instantsearch.js/es/lib/escape-highlight.js
+++ b/node_modules/instantsearch.js/es/lib/escape-highlight.js
@@ -1,3 +1,7 @@
+function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
+
+function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
+
 function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
 
 function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
@@ -36,13 +40,19 @@ function recursiveEscape(input) {
 
 export default function escapeHits(hits) {
   if (hits.__escaped === undefined) {
-    hits = hits.map(function (hit) {
-      if (hit._highlightResult) {
-        hit._highlightResult = recursiveEscape(hit._highlightResult);
+    // We don't override the value on hit because it will mutate the raw results
+    // instead we make a shallow copy and we assign the escaped values on it.
+    hits = hits.map(function (_ref) {
+      var _highlightResult = _ref._highlightResult,
+          _snippetResult = _ref._snippetResult,
+          hit = _objectWithoutProperties(_ref, ["_highlightResult", "_snippetResult"]);
+
+      if (_highlightResult) {
+        hit._highlightResult = recursiveEscape(_highlightResult);
       }
 
-      if (hit._snippetResult) {
-        hit._snippetResult = recursiveEscape(hit._snippetResult);
+      if (_snippetResult) {
+        hit._snippetResult = recursiveEscape(_snippetResult);
       }
 
       return hit;
diff --git a/node_modules/instantsearch.js/es/widgets/index/index.js b/node_modules/instantsearch.js/es/widgets/index/index.js
index b6ce713..525d00d 100644
--- a/node_modules/instantsearch.js/es/widgets/index/index.js
+++ b/node_modules/instantsearch.js/es/widgets/index/index.js
@@ -24,8 +24,29 @@ var withUsage = createDocumentationMessageGenerator({
 export function isIndexWidget(widget) {
   return widget.$$type === 'ais.index';
 }
+/**
+ * This is the same content as helper._change / setState, but allowing for extra
+ * _isFromAddWidget, which we use to decide whether local ui state invalidates.
+ */
+
+function privateHelperSetState(helper, _ref) {
+  var state = _ref.state,
+      isPageReset = _ref.isPageReset,
+      _isFromAddWidget = _ref._isFromAddWidget;
+
+  if (state !== helper.state) {
+    helper.state = state;
+    helper.emit('change', {
+      state: helper.state,
+      results: helper.lastResults,
+      isPageReset: isPageReset,
+      _isFromAddWidget: _isFromAddWidget
+    });
+  }
+}
 
 function getLocalWidgetsState(widgets, widgetStateOptions) {
+  var initialUiState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
   return widgets.filter(function (widget) {
     return !isIndexWidget(widget);
   }).reduce(function (uiState, widget) {
@@ -34,7 +55,7 @@ function getLocalWidgetsState(widgets, widgetStateOptions) {
     }
 
     return widget.getWidgetState(uiState, widgetStateOptions);
-  }, {});
+  }, initialUiState);
 }
 
 function getLocalWidgetsSearchParameters(widgets, widgetSearchParametersOptions) {
@@ -60,9 +81,12 @@ function resetPageFromWidgets(widgets) {
   }
 
   indexWidgets.forEach(function (widget) {
-    var widgetHelper = widget.getHelper(); // @ts-ignore @TODO: remove "ts-ignore" once `resetPage()` is typed in the helper
-
-    widgetHelper.setState(widgetHelper.state.resetPage());
+    var widgetHelper = widget.getHelper();
+    privateHelperSetState(widgetHelper, {
+      // @ts-ignore @TODO: remove "ts-ignore" once `resetPage()` is typed in the helper
+      state: widgetHelper.state.resetPage(),
+      isPageReset: true
+    });
     resetPageFromWidgets(widget.getWidgets());
   });
 }
@@ -143,16 +167,22 @@ var index = function index(props) {
       localWidgets = localWidgets.concat(widgets);
 
       if (localInstantSearchInstance && Boolean(widgets.length)) {
-        helper.setState(getLocalWidgetsSearchParameters(localWidgets, {
-          uiState: localUiState,
-          initialSearchParameters: helper.state
-        }));
+        privateHelperSetState(helper, {
+          state: getLocalWidgetsSearchParameters(localWidgets, {
+            uiState: localUiState,
+            initialSearchParameters: helper.state
+          }),
+          _isFromAddWidget: true
+        });
         widgets.forEach(function (widget) {
           if (localInstantSearchInstance && widget.init) {
             widget.init({
               helper: helper,
               parent: _this,
-              uiState: {},
+              // Only index widget uses this key. This means that the initial value
+              // is sufficient, since that index didn't yet exist. If we see wrong
+              // behavior with this, use mainIndex.getWidgetState()
+              uiState: localInstantSearchInstance._initialUiState,
               instantSearchInstance: localInstantSearchInstance,
               state: helper.state,
               templatesConfig: localInstantSearchInstance.templatesConfig,
@@ -205,12 +235,12 @@ var index = function index(props) {
 
       return this;
     },
-    init: function init(_ref) {
+    init: function init(_ref2) {
       var _this2 = this;
 
-      var instantSearchInstance = _ref.instantSearchInstance,
-          parent = _ref.parent,
-          uiState = _ref.uiState;
+      var instantSearchInstance = _ref2.instantSearchInstance,
+          parent = _ref2.parent,
+          uiState = _ref2.uiState;
       localInstantSearchInstance = instantSearchInstance;
       localParent = parent;
       localUiState = uiState[indexId] || {}; // The `mainHelper` is already defined at this point. The instance is created
@@ -258,8 +288,8 @@ var index = function index(props) {
       // It makes sense to replicate it at the `init` step. We have another
       // listener on `change` below, once `init` is done.
 
-      helper.on('change', function (_ref2) {
-        var isPageReset = _ref2.isPageReset;
+      helper.on('change', function (_ref3) {
+        var isPageReset = _ref3.isPageReset;
 
         if (isPageReset) {
           resetPageFromWidgets(localWidgets);
@@ -279,8 +309,8 @@ var index = function index(props) {
           });
         }
       });
-      derivedHelper.on('result', function (_ref3) {
-        var results = _ref3.results;
+      derivedHelper.on('result', function (_ref4) {
+        var results = _ref4.results;
         // The index does not render the results it schedules a new render
         // to let all the other indices emit their own results. It allows us to
         // run the render process in one pass.
@@ -310,12 +340,22 @@ var index = function index(props) {
       // configuration of the widget is pushed in the URL. That's what we want to avoid.
       // https://github.com/algolia/instantsearch.js/pull/994/commits/4a672ae3fd78809e213de0368549ef12e9dc9454
 
-      helper.on('change', function (_ref4) {
-        var state = _ref4.state;
+      helper.on('change', function (event) {
+        var state = event.state,
+            isPageReset = event.isPageReset; // @ts-ignore _isFromAddWidget comes from privateHelperSetState and
+        // thus isn't typed on the helper event
+
+        var _isFromAddWidget = event._isFromAddWidget;
+
+        if (isPageReset) {
+          localUiState.page = undefined;
+        }
+
         localUiState = getLocalWidgetsState(localWidgets, {
           searchParameters: state,
           helper: helper
-        }); // We don't trigger an internal change when controlled because it
+        }, // @MAJOR in a next version we can always use localUiState, instead of usually empty object), but it requires every single widget to set an empty value (or remove the state key's value) if they are not refined.
+        _isFromAddWidget ? localUiState : {}); // We don't trigger an internal change when controlled because it
         // becomes the responsibility of `setUiState`.
 
         if (!instantSearchInstance.onStateChange) {
